# 2304

# 0404

# 088D  Grid Repainting   diff 999

解答遷移  AC

計 18:45

➀ 思考

最短経路を成さない白マス以外の白マスすべてを黒く塗るのが最適。したがって、bfs で最短経路 X を調べ、HW - (X+1+ 黒マスの個数) を求めればよい

# 0405

# ☆ HHKB2020E  Lamps  diff 1399

降参

➀ 思考

そのマスを照らせるマスの個数 x を求めておくと、Σ (2^x-1) * (2^(K-x)) で計上できる。⇒ TLE/ 勘違いしていたが、そのマスを照らせるマスを計上するために素直に直進する処理を行うことは O(HW * (H+W)) で間に合わない。

工夫として二次元 imos 法で計上しようとしたが、全然うまくいかず降参

➁ 解法

1, 区間計上

まず、この問題は二次元 imos で解決しやすい区間問題ではない。二次元 imos は一次元 imos の純粋な拡張ではないからである。

129D Lamps のようにそのマスから照らせるマスを、近接 # マスを二分探索で調べて計上する処理が区間の数え上げには簡単だと思われる。

もしくは、そのマスから左に何マス照らせるかを調べたテーブル、右に何マス照らせるかを調べたテーブル、下、上、それぞれを　O(HW) で作成し、L+R+D+U-1 で計上するのも良い。こちらの方が二分探索より高速

2, 個数計上

(pow(2,count,MOD) - 1) × pow(2,K-count,MOD) で計上する場合、pow処理で log2000 = 10 要してしまうと、掛け算を O(n) で行った場合、全体で O(10n × HW) となり、定数倍が重くてTLE してしまう。

この時、DP の要領で pow テーブルを作成しておけば 2^X を O(1) で求めることが可能になる。

③ 感想

pow で計算量を削減する問題に初めてであった。この問題の肝である個数数え上げは 10分たらずにできたのに、尺取り法にこだわり過ぎて区間計上できなかった点、本質ではない pow で TLE 悩まされる点でとても気持ちが悪い思いをした。




# 0406

# 052D  Walk and Teleport  diff  1060

解答遷移 AC

計 04:18

➀ 思考

町は昇順に訪問できるので、単純に (X[i] - X[i-1]) * A と B を比べ続ければよい。


# 0407 

#  aising 2019   Alternating Path   diff 1264

解答遷移 AC

計測なし

➀ 思考

(最初は始点と終点に色の制限はないと誤認している)

二部グラフっぽい問題だが、dp[i][j]: マス(i,j) に到達できる始点マスの数 を定義し、隣接マスが異なる色なら、dp[nex_
i][nex_j] += nex[i][j] +1 とすれば最終的に全マスにおいて、そのマスに到達できる始点のマスの個数を求められると考えた。⇒ しかし、例えば 2×2 の領域で、対角線上に同じ色が配色されている状況では、右下のマスに到達できるマスは 3つ になるはずだが、これでは 4つ としてしまう。((1,0) , (0,1) のどちらのルートでも (0,0) を含めてしまうから) 


次に、ある始点から到達可能なマスを X個 とすると、この領域における条件を満たす組み合わせは XC2 となることに注目し、bfs でこの領域を求めることを考えた。一度見たマスは再探索しないことにすると、始点を全探索しても計算量は O( 4HW ) と十分高速。⇒ ここでようやく始点と終点は異なる色である条件に気付いて、領域内の白色マス、黒色マスをそれぞれ計上してその積を累積した値を答えにすればよいと判断した。

# 0408 

# 215E Chain Contestant   diff  1413

解答遷移 AC

計 36:53

➀ 思考

dp[i][j][k] : i 番目までのコンテストにおいて、出場履歴 j かつ 最後に出たコンテストが k となる場合の数 と定義すればよいと判断。履歴 j は 10 桁のbit で表現することで 計算量 O(N × 2^10  × 10) で十分高速。

どのコンテストにも出場していない状態(初期状態) を管理する方法に迷った。コンテストの種類を ? A,B,...J の11種にしてしまうと bit 計算がずれてしまうのでこれは却下。ここで、dp[i][0][0] (出場経験なし　かつ 最後にコンテスト AAC に出場している状態 ) を初期状態としても問題が生じないことに気づいて実装した。


# 0411

# 102D  Linear Approximation   diff 1089

解答遷移 AC

計 1:08:03

➀ 思考

Ai - i で置き換える。30分以上様々に考察した後、昇順に並び替えた中間位置の値を X として、 全要素から X を引くのが最大であることに気が付いた。これは以下の理由で説明できる。

X 以下で最小の値を X' （X' ≦ X) とすると、0≦ B ≦ X' までの間は X 以外の値の総和が減少し続け、その後( X'< B ≦ X) X 以外の要素の総和は一定の値をとり続ける。この間 X は単調に減少するので、B = X とすることで総和は最小になるとわかる。

偶奇で場合分けが必要になりそうだと思ったがその必要がないことがわかり、X　を求めた後、素直に全要素から X を引いた絶対値を累積して完了


# 0413

# ☆ 105D Base-2 Number   diff 1204

解答遷移 AC

計 1:34:02

➀ 思考

通常 N 1に到達するまで 「 奇数なら1 引きながら、2で割り続けること」を繰り返した履歴をもとに復元 ( 1 ⇒ 2 ( → +1)  ⇒ 4  ( → +1 ) ... ) することで Nの2進数表示を求めることができる。このとき桁の移項を 2倍(bitシフト) で表現できるが、この問題で桁の移項が -2倍に一致することになるので全く同じ要領では解くことができない。

そこで、任意の正整数 X の -2進数表示 X'(-2) として、この値を利用して **-X の2進数表示を求めること** ができれば、1 → (-1) ⇒ 2 → (-2) ⇒ 4 → (-4) .... と通常の2進数表示を求める場合と似た要領で すべての整数の -2 進数表示を求めることができそうだと考えた。

ここで、-4(2) = -8 + 4 = 1000 + 100 = 1100 であるように、-X'(-2) = X'<<1 + X' が成立する。したがって、-X'(-2) を求めるためには、X'(-2) の各桁を1ずらしていけばよいとわかる。ただし、連続して 1 が存在する桁では、このシフトでより上位の桁が 0 になる。これは例えば 110(-2) ⇔ 4 + (-2) + 0 において、1桁目で -2<<1 とすることで 4 を求められるが、この値と 2桁目の正負転換値が相殺されることになるからである。( -2 = 10(-2) , 2 = 110(-2) ) 

以上、正負の変換が自由に行えるので abs(N) でとりあえず -2進数表示を求めて、N<0 なら変換することにする。abs(N) から 1 までの 操作履歴で、、1 → (-1) ⇒ 2 → (-2) ⇒ 4 → (-4) .... ⇒ abs(N) と求めればよい。計算量は　O( (log2abs(N)) ^2 )※ で十分高速。

※ 正負を入れ替える際、-2進数表示を逆に処理することで連続した 1 を検出しやすくなるので、毎度 -2 進数表示を表現するリストを逆順処理している。履歴の数が log2abs(N) , その都度 O(log2abs(N)) でリストを逆順処理しているので全体の計算量が上記のように推定される

➁　解法

2進数表示とは Ai × 2^(i) + Ai-1 × 2^(i-1) + .... + A0 × 2^0 変換であるので、2で割ることを繰り返した余りを求めればよいのだ。-2 進数表示も全く同じなので、-2 で割ることを繰り返した余りを求めればよい。


③ 感想

普通に時間をかけず解けなきゃな問題。文字列と26進数表示の問題で、よく考えた仕組みだったのにすっかり抜け落ちてしまっていた。



























